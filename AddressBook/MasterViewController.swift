// MasterViewController.swift
// Manages the contact list and contains various autogenerated Core Data
// code, some of which we modified to use the Contact class
import UIKit
import CoreData

class MasterViewController: UITableViewController,
    NSFetchedResultsControllerDelegate, 
    AddEditTableViewControllerDelegate,
    DetailViewControllerDelegate {
    
    var detailViewController: DetailViewController? = nil
    var managedObjectContext: NSManagedObjectContext? = nil
    
    // configure popover for UITableView on iPad
    override func awakeFromNib() {
        super.awakeFromNib()
        if UIDevice.currentDevice().userInterfaceIdiom == .Pad {
            self.clearsSelectionOnViewWillAppear = false
            self.preferredContentSize =
                CGSize(width: 320.0, height: 600.0)
        }
    }
    
    // called just before MasterViewController is presented on the screen
    override func viewWillAppear(animated: Bool) {
        super.viewWillAppear(animated)
        displayFirstContactOrInstructions()
    }
    
    // if the UISplitViewController is not collapsed,
    // select first contact or display InstructionsViewController
    func displayFirstContactOrInstructions() {
        if let splitViewController = self.splitViewController {
            if !splitViewController.collapsed {
                // select and display first contact if there is one
                if self.tableView.numberOfRowsInSection(0) > 0 {
                    let indexPath = NSIndexPath(forRow: 0, inSection: 0)
                    self.tableView.selectRowAtIndexPath(indexPath,
                        animated: false,
                        scrollPosition: UITableViewScrollPosition.Top)
                    self.performSegueWithIdentifier(
                        "showContactDetail", sender: self)
                } else { // display InstructionsViewController
                    self.performSegueWithIdentifier(
                        "showInstructions", sender: self)
                }
            }
        }
    }
    
    // called after the view loads for further UI configuration
    override func viewDidLoad() {
        super.viewDidLoad()
        
        if let split = self.splitViewController {
            let controllers = split.viewControllers
            self.detailViewController =
                controllers[controllers.count-1].topViewController as?
                    DetailViewController
        }
    }
    
    // configure destinationViewController based on segue
    override func prepareForSegue(segue: UIStoryboardSegue,
        sender: AnyObject?) {
        if segue.identifier == "showContactDetail" {
            if let indexPath = self.tableView.indexPathForSelectedRow() {
                // get Contact for selected cell
                let selectedContact =
                    self.fetchedResultsController.objectAtIndexPath(
                        indexPath) as Contact
                
                // configure DetailViewController
                let controller = (segue.destinationViewController as
                    UINavigationController).topViewController as
                    DetailViewController
                controller.delegate = self
                controller.detailItem = selectedContact
                controller.navigationItem.leftBarButtonItem =
                    self.splitViewController?.displayModeButtonItem()
                controller.navigationItem.leftItemsSupplementBackButton =
                    true
            }
        } else if segue.identifier == "showAddContact" {
            // create a new Contact object that is not yet managed
            let entity =
                self.fetchedResultsController.fetchRequest.entity!
            let newContact = Contact(entity: entity,
                insertIntoManagedObjectContext: nil)
            
            // configure the AddEditTableViewController
            let controller = (segue.destinationViewController as
                UINavigationController).topViewController as
                AddEditTableViewController
            controller.navigationItem.title = "Add Contact"
            controller.delegate = self
            controller.editingContact = false // adding, not editing
            controller.contact = newContact
        }
    }
    
    // called by AddEditViewController after a contact is added
    func didSaveContact(controller: AddEditTableViewController) {
        // get NSManagedObjectContext and insert new contact into it
        let context = self.fetchedResultsController.managedObjectContext
        context.insertObject(controller.contact!)
        self.navigationController?.popToRootViewControllerAnimated(true)
        
        // save the context to store the new contact
        var error: NSError? = nil
        if !context.save(&error) { // check for error
            displayError(error, title: "Error Saving Data",
                message: "Unable to save contact")
        } else { // if no error, display new contact details
            let sectionInfo =
                self.fetchedResultsController.sections![0] as
                    NSFetchedResultsSectionInfo
            if let row = find(sectionInfo.objects as [NSManagedObject],
                controller.contact!) {
                let path = NSIndexPath(forRow: row, inSection: 0)
                tableView.selectRowAtIndexPath(path,
                    animated: true, scrollPosition: .Middle)
                performSegueWithIdentifier("showContactDetail",
                    sender: nil)
            }
        }
    }
    
    // called by DetailViewController after a contact is edited
    func didEditContact(controller: DetailViewController) {
        let context = self.fetchedResultsController.managedObjectContext
        var error: NSError? = nil
        if !context.save(&error) {
            displayError(error, title: "Error Saving Data",
                message: "Unable to save contact")
        }
    }
        
    // indicate that an error occurred when saving database changes
    func displayError(error: NSError?, title: String, message: String) {
        // create UIAlertController to display error message
        let alertController = UIAlertController(title: title,
            message: String(format: "%@\nError:\(error)\n", message),
            preferredStyle: UIAlertControllerStyle.Alert)
        let okAction = UIAlertAction(title: "OK",
            style: UIAlertActionStyle.Cancel, handler: nil)
        alertController.addAction(okAction)
        presentViewController(alertController, animated: true,
            completion: nil)
    }
    
    // UITableViewDelegate methods
    // callback that returns total number of sections in UITableView
    override func numberOfSectionsInTableView(
        tableView: UITableView) -> Int {
        return self.fetchedResultsController.sections?.count ?? 0
    }
    
    // callback that returns number of rows in the UITableView
    override func tableView(tableView: UITableView,
        numberOfRowsInSection section: Int) -> Int {
        let sectionInfo =
            self.fetchedResultsController.sections![section] as
                NSFetchedResultsSectionInfo
        return sectionInfo.numberOfObjects
    }
    
    // callback that returns a configured cell for the given NSIndexPath
    override func tableView(tableView: UITableView,
        cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCellWithIdentifier(
            "Cell", forIndexPath: indexPath) as UITableViewCell
        self.configureCell(cell, atIndexPath: indexPath)
        return cell
    }
    
    // callback that returns whether a cell is editable
    override func tableView(tableView: UITableView,
        canEditRowAtIndexPath indexPath: NSIndexPath) -> Bool {
        return true
    }
    
    // callback that deletes a row from the UITableView
    override func tableView(tableView: UITableView,
        commitEditingStyle editingStyle: UITableViewCellEditingStyle,
        forRowAtIndexPath indexPath: NSIndexPath) {
        if editingStyle == .Delete {
            let context =
                self.fetchedResultsController.managedObjectContext
            context.deleteObject(
                self.fetchedResultsController.objectAtIndexPath(
                    indexPath) as Contact)
            
            var error: NSError? = nil
            if !context.save(&error) {
                displayError(error, title: "Unable to Load Data",
                    message: "AddressBook unable to acccess database")
            }
            
            displayFirstContactOrInstructions()
        }
    }
    
    // called by line 174 to configure a cell
    func configureCell(cell: UITableViewCell,
        atIndexPath indexPath: NSIndexPath) {
        let contact = self.fetchedResultsController.objectAtIndexPath(
            indexPath) as Contact
        cell.textLabel!.text = contact.lastname
        cell.detailTextLabel!.text = contact.firstname
    }
    
    // Core Data autogenerated code for interacting with the data model;
    // sightly modified to work with the Contact entity
    var fetchedResultsController: NSFetchedResultsController {
        if _fetchedResultsController != nil {
            return _fetchedResultsController!
        }
        
        let fetchRequest = NSFetchRequest()
        
        // edited to use the Contact entity
        let entity = NSEntityDescription.entityForName("Contact",
            inManagedObjectContext: self.managedObjectContext!)
        fetchRequest.entity = entity
        
        // Set the batch size to a suitable number.
        fetchRequest.fetchBatchSize = 20
        
        // edited to sort by last name, then first name;
        // both using case insensitive comparisons
        let lastNameSortDescriptor = NSSortDescriptor(key: "lastname",
            ascending: true, selector: "caseInsensitiveCompare:")
        let firstNameSortDescriptor = NSSortDescriptor(key: "firstname",
            ascending: true, selector: "caseInsensitiveCompare:")
        
        fetchRequest.sortDescriptors =
            [lastNameSortDescriptor, firstNameSortDescriptor]
        
        // Edit the section name key path and cache name if appropriate.
        // nil for section name key path means "no sections".
        let aFetchedResultsController = NSFetchedResultsController(
            fetchRequest: fetchRequest,
            managedObjectContext: self.managedObjectContext!,
            sectionNameKeyPath: nil, cacheName: "Master")
        aFetchedResultsController.delegate = self
        _fetchedResultsController = aFetchedResultsController
        
        var error: NSError? = nil
        if !_fetchedResultsController!.performFetch(&error) {
            displayError(error, title: "Error Fetching Data",
                message: "Unable to get data from database")
        }
        
        return _fetchedResultsController!
    }
    var _fetchedResultsController: NSFetchedResultsController? = nil
    
    func controllerWillChangeContent(
        controller: NSFetchedResultsController) {
        self.tableView.beginUpdates()
    }
    
    func controller(controller: NSFetchedResultsController,
        didChangeSection sectionInfo: NSFetchedResultsSectionInfo,
        atIndex sectionIndex: Int,
        forChangeType type: NSFetchedResultsChangeType) {
        switch type {
        case .Insert:
            self.tableView.insertSections(NSIndexSet(index: sectionIndex),
                withRowAnimation: .Fade)
        case .Delete:
            self.tableView.deleteSections(NSIndexSet(index: sectionIndex),
                withRowAnimation: .Fade)
        default:
            return
        }
    }
    
    func controller(controller: NSFetchedResultsController,
        didChangeObject anObject: AnyObject,
        atIndexPath indexPath: NSIndexPath?,
        forChangeType type: NSFetchedResultsChangeType,
        newIndexPath: NSIndexPath?) {
        switch type {
        case .Insert:
            tableView.insertRowsAtIndexPaths(
                [newIndexPath!], withRowAnimation: .Fade)
        case .Delete:
            tableView.deleteRowsAtIndexPaths(
                [indexPath!], withRowAnimation: .Fade)
        case .Update:
            self.configureCell(
                tableView.cellForRowAtIndexPath(indexPath!)!,
                atIndexPath: indexPath!)
        case .Move:
            tableView.deleteRowsAtIndexPaths(
                [indexPath!], withRowAnimation: .Fade)
            tableView.insertRowsAtIndexPaths(
                [newIndexPath!], withRowAnimation: .Fade)
        default:
            return
        }
    }
    
    func controllerDidChangeContent(
        controller: NSFetchedResultsController) {
        self.tableView.endUpdates()
    }
    
    /*
    // Implementing the above methods to update the table view in response 
    // to individual changes may have performance implications if a large 
    // number of changes are made simultaneously. If this proves to be an 
    // issue, you can instead just implement controllerDidChangeContent: 
    // which notifies the delegate that all section and object changes 
    // have been processed.
    
    func controllerDidChangeContent(
        controller: NSFetchedResultsController) {
        // In the simplest, most efficient, case, reload the table view.
        self.tableView.reloadData()
    }
    */
}




/*************************************************************************
* (C) Copyright 2015 by Deitel & Associates, Inc. All Rights Reserved.   *
*                                                                        *
* DISCLAIMER: The authors and publisher of this book have used their     *
* best efforts in preparing the book. These efforts include the          *
* development, research, and testing of the theories and programs        *
* to determine their effectiveness. The authors and publisher make       *
* no warranty of any kind, expressed or implied, with regard to these    *
* programs or to the documentation contained in these books. The authors *
* and publisher shall not be liable in any event for incidental or       *
* consequential damages in connection with, or arising out of, the       *
* furnishing, performance, or use of these programs.                     *
*                                                                        *
* As a user of the book, Deitel & Associates, Inc. grants you the        *
* nonexclusive right to copy, distribute, display the code, and create   *
* derivative apps based on the code. You must attribute the code to      *
* Deitel & Associates, Inc. and reference the book's web page at         *
* www.deitel.com/books/ios8fp1/. If you have any questions, please email *
* at deitel@deitel.com.                                                  *
*************************************************************************/



